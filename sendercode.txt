		
#Thread Class to handle the sending of a single packet
class sender(threading.Thread):
	def __init__(self, cSock, hst, prt, msg, s):
		threading.Thread.__init__(self)
		self.timer = time.time()
		self.data = msg				#DATA OF 1 MSS SIZE TO BE SENT
		self.seqNum = s				#SEQUENCE NUMBER OF THE PACKET
		self.sock = cSock
		self.host = hst				#SERVER IP ADDRESS
		self.port = prt				#SERVER PORT
		self.start()
	
	def computeChecksum(self, data):
		sum = 0
		for i in range(0, len(data), 2):
			if i+1 < len(data):
				data16 = ord(data[i]) + (ord(data[i+1]) << 8)		#To take 16 bits at a time
				interSum = sum + data16
				sum = (interSum & 0xffff) + (interSum >> 16)		#'&' to ensure 16 bits are returned
		return ~sum & 0xffff										#'&' to ensure 16 bits are returned
				
	def formPacket(self, data, seq):
		#32 bit sequence number
		#16 bit check of the data part
		#16 bit 0101010101010101 -- Indicates data packet(in int 21845)
		seqNum = struct.pack('=I',seq)
		checksum = struct.pack('=H',self.computeChecksum(data))		#Computes the checksum of data
		dataIndicator = struct.pack('=H',21845)
		packet = seqNum+checksum+dataIndicator+bytes(data,'UTF-8')
		return packet
	
	def run(self):
		global acked
		packet = self.formPacket(self.data, self.seqNum)				#Packets are created here
		self.sock.sendto(packet,(self.host, self.port))
		try:
			while acked < self.seqNum:
				diff = time.time() - self.timer
				if  diff < 5:									#RETRANSMISSION time = 5 seconds
					pass
				else:
					if acked < self.seqNum:								#Rechecking the ACK
						print('TIMEOUT, SEQUENCE NUMBER = '+str(self.seqNum))
						self.sock.sendto(packet,(self.host, self.port))	#RETRANSMISSION of time-out packets(No ACK Received)
						self.timer = time.time()
		except:
			print('Server closed its connection')
			self.sock.close()